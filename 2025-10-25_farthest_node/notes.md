# 가장 먼 노드

**작성일**: 2025-10-25</br>
**목표**: 1번 노드에서 가장 멀리 떨어진 노드의 개수 구하기 (최단 거리 기반의 그래프 탐색 문제)

---

## 최초 제출(MySubmit.java) 시 틀린 부분
1. **다익스트라 로직 방향 혼동**
   - `PriorityQueue` 정렬을 내림차순(`b.count - a.count`)으로 둬서 가장 먼 노드부터 꺼냈음.
   - 하지만 최단 거리 계산에서는 가장 가까운 노드부터 방문해야 함.
   - 결과적으로 거리 값이 계속 갱신되며 무한 루프 발생.

2. **갱신 조건 반대 사용**
   - `if (result[nextTo] < nextCount)` 로 “더 먼 거리일 때만 갱신” → 최단 거리 탐색 원리에 반함.
   - “더 짧은 거리로 갈 수 있을 때만 갱신” 해야 함 (`if (nextCount < result[nextTo])`).

3. **문제 요구사항 해석 착오**
    - “가장 먼 노드”를 “가장 긴 경로”로 오해.
    - 실제로는 “최단 거리들 중 가장 큰 값을 갖는 노드 개수”를 의미.
    - 즉, “최단 거리 계산 후 최대값 `count`” 로 해결해야 함.

4. **불필요한 복잡도**
    - 가중치가 모두 1인데 `PriorityQueue` 기반 Dijkstra 사용 → 가능은 하지만 비효율.
    - BFS로 충분하며 더 간단하고 안전.

---

## 2차 제출(MySolution.java) 시 수정한 부분
- `Queue<Edge>`로 단순 BFS 구현 (가중치=1이므로 PQ 불필요)
- `nextCount < result[nextTo]` 조건으로 최단 거리만 갱신

---

## 헷갈렸던 것/ 새로 배운 것
- “가장 먼 노드” = “최단 거리 중 가장 큰 값”이라는 정의
- BFS는 무가중치 그래프에서 Dijkstra와 동등
- `PriorityQueue`는 항상 가장 작은 거리부터 꺼내야 최단 거리 보장
- 거리 배열을 초기화할 땐 `Integer.MAX_VALUE / 2` 정도로 안전하게 설정 (overflow 방지)

---

## 기억할 포인트
- 간선 가중치가 모두 1이면 BFS, 가중치가 다양하면 Dijkstra
- 최단 거리 탐색에서는 항상 “작은 쪽으로 갱신”
- 무한 루프 의심 시 `visited` 또는 거리 갱신 조건 먼저 확인
- 최댓값 세기 전, `Arrays.sort()` 대신 한 번의 순회로 max/count 계산

