# 디스크 컨트롤러

**작성일**:2025-10-16</br>
**목표**: SJF(Shortest Job First) 스케줄링 원리를 적용해 평균 작업 처리 시간을 최소화하는 알고리즘 구현

---

## 최초 제출(MySubmit.java) 시 틀린 부분
1. **모든 작업을 한꺼번에 큐에 넣음**
   - `for`문으로 전체 작업을 `PriorityQueue`에 바로 추가했음.
   - 요청 시점(`requestedAt`)이 고려되지 않아, 아직 도착하지 작업이 먼저 처리되는 문제 발생.
   - 스케줄링에서 “현재 시점까지 도착한 작업만” 큐에 추가해야 함.

2. **시간 흐름을 시뮬레이션하지 않음**
   - `currentTime`이 단순히 작업 처리시간만 누적됨.
   - 큐가 비는 구간(= 아직 아무 작업도 도착하지 않은 시간대)을 고려하지 않아 idle 상태 미반영.
   - `waitingQueue.isEmpty()`일 때 다음 작업의 요청 시각으로 `currentTime`을 점프.

3. **중복 추가 및 무한 루프 발생**
    - `for`문으로 모든 작업을 반복 확인하며 매번 PQ에 추가함.
    - 이미 큐에 들어간 작업이 계속 다시 들어가거나, 아직 도착하지 않은 작업까지 접근하며 `index`가 끝까지 증가 → 무한 루프 유발.
    - `index` 포인터(참조만 하기)를 도입해 “한 번만 PQ에 넣은 작업”은 다시 보지 않도록 제어.

---

## 2차 제출(MySolution.java) 시 수정한 부분
- `jobs`를 도착 시각 기준으로 정렬하여 순차 탐색 가능하게 만듦.
- `PriorityQueue`를 소요시간 기준(min-heap)으로 정렬하여 SJF 구조 반영
- `while(index < size && jobs[index][0] <= currTime)` 조건을 통해 현재 시점까지 도착한 작업만 PQ에 추가하도록 수정.
- 큐가 비었을 경우 다음 작업의 도착 시점으로 시간 점프(`currTime = jobs[index][0]`) 추가.
- `index`와 `doneCount`를 별도로 관리해 중복 삽입/무한 루프 문제 제거.

---

## 헷갈렸던 것/ 새로 배운 것
- 시간은 1초씩 흐르는 것보다 이벤트 단위로 점프, 즉 건너뛰는 것이 효율적임.
- SJF 스케줄링은 지금 시점에 실행 가능한 작업들 중 가장 짧은 것을 고르는 문제지, 전체 작업 중 가장 짧은 걸 먼저 고르는 문제가 아님.
- 우선순위 큐(PQ) 는 “지금 처리 가능한 후보”들만 담는 임시 저장소. → 모든 작업을 처음부터 PQ에 넣으면 아직 오지도 않는 작업까지 경쟁하게 됨.
- `index`는 다음에 PQ에 넣을 작업의 위치를 의미(한 번 PQ에 들어간 작업은 다시 볼 필요가 없음).
- `currentTime`과 `index`, `doneCount`는 각각 역할을 나눠서 시간 시뮬레이션을 담당.
    - 시간 흐름 제어
    - 도착 관리
    - 처리 개수 관리

---

## 기억할 포인트
- 스케줄링/시뮬레이션 문제는 항상 → 정렬 + PQ + 현재 시점 관리(currentTime) 의 3단계 구조로 접근한다.
- `currentTime`이 갱신될 때마다 그 시점까지 도착한 작업만 PQ에 삽입한다.
- `PQ.isEmpty()`→ 다음 이벤트 시점으로 점프.
- SJF(Shortest Job First) 구조는 곧 다익스트라(최단거리) 구조의 미니 버전이라고 함(“현재 상태에서 가장 짧은 비용 경로를 선택한다”는 로직이 같다)

