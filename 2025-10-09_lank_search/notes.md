# 순위 검색

**작성일**: 2025-10-09
**목표**: 
- info 배열과 query 배열을 효율적으로 매칭하여 조건을 만족하는 지원자 수를 빠르게 계산한다.
- 문자열 전처리, 다중 조합 생성(Map), 정렬, 이분 탐색의 전체 흐름을 체득한다.

---

## 최초 제출(MySubmit.java) 시 틀린 부분
1. **Stream filter 기반 완전 탐색**
   - `infoList.stream().filter()`를 사용하여 매 쿼리마다 전체 info를 순회함.
   - 5만 × 10만 = 50억 번 비교 → 효율성 전부 실패.
   - 효율성 0점, 정확성만 통과함.

2. **Map 미활용 (전처리 부재)**
   - 매 쿼리마다 조건을 실시간 비교하여 중복 계산 다수 발생.
   - `HashMap`을 이용한 조건별 점수 누적을 생각하지 못함.

3. **전처리 순서 미비**
    - 조합(`makeAllCombinations`)을 따로 만들고 점수를 나중에 넣으려 함.
    - 실제로는 info 하나 읽을 때 바로 16개의 key를 만들고 점수를 누적해야 효율적임.

4. **이분 탐색 미적용**
    - 점수 리스트를 단순 for문으로 순회하며 `score >= queryScore`를 계산.
    - 최악의 경우 모든 리스트를 다 돌아야 해서 효율성 실패.

---

## 2차 제출(MySolution.java) 시 수정한 부분
1. **전처리 + 조합 + 누적**
    - info 한 건을 읽을 때 즉시 16개의 key를 만들고, 해당 key 리스트에 점수 누적 => info에 존재하는 재료로만 경우의 수 map제작, 불필요한 108개 모두 만들필요 없음.
2. **정렬 방향 변경 (내림차순 → 오름차순)**
    - `binary search`를 쓰기 위해 `Collections.sort(list)`로 정렬.
    - 각 key의 리스트를 한 번만 정렬 → 이후 빠른 검색 가능.
3. **이분 탐색(lower bound) 적용**
    - for문 대신 `logN(중요!)` 탐색 구조 적용.
    - `while (start < end)` 반복문으로 score 이상이 처음 등장하는 위치 탐색.
    - 결과 계산: `list.size() - start`.

---

## 헷갈렸던 것/ 새로 배운 것
- **“모든 조합 만들기”의 의미**
    - 108개 조합을 미리 만드는 게 아니라,
    - “info 한 건이 들어올 때” 4개 속성에 대해 `원래값 / '-'` 두 가지씩 선택 → 2⁴=16개의 key 생성.
    - 전체 key 종류는 108개일 수 있지만, 한 info가 만드는 건 16개뿐임.

- **이분 탐색의 작동 원리**
    - 정렬된 배열에서 중간값을 기준으로 “score 이상이 나오는 첫 번째 위치”를 찾을 때마다 탐색 범위를 반씩 줄여나감.
    - `list[mid] < target` → 오른쪽 절반으로 이동
    - `list[mid] >= target` → 왼쪽 절반으로 이동
    - 반복 종료 시 `start == end`가 조건을 만족하는 첫 인덱스.

- **정렬 + 탐색의 관계**
    - “정렬은 빠른 탐색을 위한 준비, 이분 탐색은 실제 빠른 탐색 수행 도구.”
    - (오름차순)정렬 없이는 절반 단위로 나눌 수 없음.

- **HashMap과 List의 협력 구조**
    - Map의 key는 “조건 조합 문자열”,
    - value는 “해당 조건에 맞는 모든 점수들의 정렬 리스트”.
    - 쿼리가 들어오면 key로 접근 후 binary search.
---

## 기억할 포인트
- info 하나를 읽을 때 → 즉시 16개의 key 생성 + 점수 누적
- 정렬은 오름차순으로 (binary search 전제)
- 조합 생성은 4중 for문 또는 재귀 둘 다 가능하되, info 안에서 처리해야 효율적
- lower bound 패턴:
```
    while (start < end) {
        int mid = (start + end) / 2;
        if (list.get(mid) < score) start = mid + 1;
        else end = mid;
    }
    return list.size() - start;
```
- 전체 시간 복잡도
    - 전처리: O(16N log N)
    - 쿼리: O(M log N)
    - 전체 약 2~3×10⁶ 연산 → 효율성 통과

