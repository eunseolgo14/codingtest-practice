# 보석 쇼핑

**작성일**: 2025-10-25</br>
**목표**: 1번 인덱스부터 시작하는 gems 배열 내에서 모든 보석 종류를 포함하는 가장 짧은 구간 [start, end] 찾기

---

## 최초 제출(MySubmit.java) 시 틀린 부분
1. **탐색 방식 오해 – 이분 탐색 구조 사용**
   - `left` / `right`를 배열의 인덱스가 아니라 길이 범위로 두고 움직임
   - `isHaveAllGems(left, right)`로 구간을 매번 전체 확인 → 비효율적 (O(N²×K))
   - 모든 구간을 매번 다시 검사하므로, 입력이 길면 시간 초과 발생

2. **검사 로직 오류 (isHaveAllGems)**
   - `for(String gem : gems)`로 전체 배열을 돌며 비교 → `start~end` 구간을 제한하지 않음
   - `hitCount++` 방식으로 중복을 모두 세서, 같은 종류의 보석이 여러 번 등장하면 `hitCount > gemSet.size()`가 되어버림
   - 즉, “모든 보석이 포함되었는가”를 정확히 표현하지 못함

3. **갱신 조건 부재**
    - 구간이 모든 보석을 포함했을 때 “최소 길이 갱신” 로직이 없음
    - 단순히 `right--`, `left++`만 반복하며, 결과적으로 올바른 최소 구간이 계산되지 않음

4. **시간 복잡도 폭발**
    - `isHaveAllGems()` 내부에서 보석 종류(K) × 구간 길이(N) 만큼 반복
    - 이 함수를 모든 구간(left~right)에 대해 반복 호출 → `O(N³)` 수준
    -  


---

## 2차 제출(MySolution.java) 시 수정한 부분
- 이분 탐색 제거 → 투 포인터(슬라이딩 윈도우) 구조로 전환
    - `while (lMove <= rMove && rMove < gems.length)`으로 구간을 실시간으로 확장/축소하며 관리
    - 매번 전체를 새로 확인하지 않고, 현재 윈도우 상태만 갱신

- `Map<String, Integer>`로 구간 내 보석 개수 관리
    - 중복된 보석 등장 시 카운트 증가, 왼쪽 포인터 이동 시 감소
    - 카운트가 0이 되면 `rangeMap.remove()` → 실시간으로 포함된 종류 추적

- 모든 보석을 포함하면 최소 구간 갱신
    - `if (rangeMap.size() == gemSet.size())`일 때, `(rMove - lMove)` 최소값 비교 후 `finalL`, `finalR` 저장

- 효율성 개선
    - 모든 요소를 한 번씩만 left/right 포인터로 통과 → `O(N)`
    - 공간 복잡도도 `O(K)`로 최적

---

## 헷갈렸던 것/ 새로 배운 것
- 슬라이딩 윈도우는 누적합 문제(합의 변화) 뿐 아니라 조건을 만족하는 최소/최대 구간 탐색에도 적용할 수 있다.
- “모든 보석 포함 여부”를 매번 새로 검사하는 대신, Map으로 실시간 상태 관리하면 훨씬 빠르고 깔끔하다.
- `rangeMap.size() == gemSet.size()`가 “현재 구간이 모든 보석을 포함했다”는 핵심 조건.
- 왼쪽 포인터를 옮길 때 반드시 rangeMap을 수정해야 한다(그렇지 않으면 구간이 실제로 줄어들지 않음).

---

## 기억할 포인트
- 슬라이딩 윈도우의 본질: 
    - “전체를 매번 다시 보지 않고, 변화가 생긴 부분만 갱신한다.”
- 보석 쇼핑 핵심 패턴:
    - 오른쪽 포인터 → 구간 확장 (조건 채워질 때까지)
    - 왼쪽 포인터 → 불필요한 부분 제거 (조건 유지하며 최소화)
- Map 관리 요령:
    - 추가 시 `map.put(gem, getOrDefault(gem, 0) + 1)`
    - 제거 시 개수 0이면 `map.remove(gem)`
- 최종 구간 출력 시 1-based 인덱스로 변환 필수
    - `(finalL + 1, finalR + 1)`

