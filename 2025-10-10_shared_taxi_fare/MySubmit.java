//fares를 기준으로 그래프를 구성한다. 
//그래프의 총 길이는 노드 수
//각 그래프는 구성 가능한 간선 정보 Edge를 리스트 형식으로 가지고 있음

//무방향 그래프임으로 fares한개당 2개씩의 grapg에 Edge와 Fare를 추가
//그래프 구성 완료

//다익스트라를 3번 반복하여 모든 경로 산출한다.
//s지점에서 모든 노드까지 경로와 비용
//a지점에서 모든 노드까지 경로와 비용
//b지점에서 모든 노드까지 경로와 비용
//=> 위 세 경로는 추후 각 노드 분기점으로 비용 산출 시 사용

//그래프 내 각 노드를 분기점으로 삼을 시 나오는 요금 산출
//위에서 산출한 각 지점별 비용을 모두 더한것을 총 비용으로 
//더 싼 경우 갱신

//다익스트라 알고리즘 구현
//임시 매우 큰 값을 정의한다 추후 여기에 수 덧셈이 이루어지는데 넘치지 않게 여유분을 둔다.
//n+1개의 롱 배열을 만든 후 그 배열 내부를 모두 무한으로 채운다.
//현재 노드에서 현재 노드까지 비용은 0으로 수정한다.

//프라이오리티 큐를 하나 마련한다.
//큐 내부는 롱 배열이라 컴페어레이터 기준이 없으니 직접 젛어준다.
//배열 내 a[1]를 오름차순 대상으로 삼는다.

//pq가 비어있을때까지 하나씩 꺼내 진행. 
//도착 노드 u와 거리 d를 poll한 값에서 분리
//갱신없이 중복 추가가 가능한 pq특성 상 dist[u]의 값과 d가 같은지 확인, 다르다면 현 dist[u]를 갱신할 필요 없으므로 continue
//같다면 해당 노드의 인접 노드 검사 필요로 for문으로 내려옴

//graph[u]로 현재 src에서 연결된 인접 노드들과의 간선 배열을 추출.
//이때 총 비용은 src에서 현 지점 비용, 그리고 현 지점에서 연결 노드까지의 비용을 더한, src -> u -> e.to(v)까지의 거리야.
//이것이 dist의 v번에 저장된 것보다 적다면 dist갱신, pq에 v와 총 비용을 추가.
//결론적으로 다익스트라 한번 돌면 src부터 각 노드를 향해 가는 가장 싼 비용만이 저장됨.

//저장된 src부터 엔드 노드까지의 최소 비용만이 담긴 dist를 리턴


//=> 1시간 동안 풀이 못함, 학습 후 메인 로직 구상으로 대체.
//완전 학습 후 위 주석을 기반으로 구현한 내용이 MySolution.java에 작성됨.

