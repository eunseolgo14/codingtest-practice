# 합승 택시 요금 (Shared Taxi Fare)

**작성일**: 2025-10-10 </br>
**목표**: 다익스트라 3회(s, a, b) + 분기점 전수(min_k)로 총 요금 최소값 계산

---

## 최초 제출(MySubmit.java) 시 틀린 부분
1. **경로 탐색 관점 오류**
   - “모든 경로를 만들어 비교해야 한다”는 관점으로 접근하려 함.
   - 최단거리의 핵심이 “노드별 현재 최저가(dist)만 갱신”이라는 점을 놓침.
   - 결과적으로 설계가 복잡해지고, 구현 방향이 흔들림.

2. **1-based / 0-based 혼용 가능성**
   - 입력은 1-based인데 내부 배열 인덱스(0-based)와 혼용될 위험이 있었음.
   - `-1` 보정 누락 시 인덱스 에러/논리 오류 발생 가능.

3. **PQ(우선순위 큐) 동작 오해**
    - PQ에 동일 노드가 여러 비용으로 들어갈 수 있다는 점을 고려하지 못함.
    - stale(낡은) 후보를 스킵하지 않으면 불필요한 완화/시간 낭비 발생.

4. **INF(무한대) 상수 취급 미흡**
    - `MAX_VALUE` 그대로 쓰면 덧셈에서 오버플로우 가능.
    - “충분히 크되 더해도 넘치지 않는 값”으로의 세팅 필요.

---

## 2차 제출(MySolution.java) 시 수정한 부분
- 다익스트라 3회 적용: `distS = dijkstra(s), distA = dijkstra(a), distB = dijkstra(b)`
- 정답 공식 적용: `ans = min_k( distS[k] + distA[k] + distB[k])`
- stale 컷 추가: `if (d != dist[u]) continue;`로 낡은 후보 스킵
- INF 여유값 사용: `Integer.MAX_VALUE - 200000` 등 덧셈 안전 범위로 설정
- 인덱스 일관화: 0-based 내부 처리(필요 지점에서만 `-1` 보정)
- 무방향 간선 양방향 추가: `u→v`, `v→u` 모두 그래프에 반영

---

## 헷갈렸던 것/ 새로 배운 것
- 왜 모든 경로를 만들지 않아도 되는가?
    - 다익스트라는 “가장 싼 후보부터 확정 → 이웃 가격 깎기(완화)” 반복.
    - 노드별 최저가(dist)만 관리하면 충분하며, 경로 전수 탐색이 아님.
- stale 후보가 생기는 이유
    - Java `PriorityQueue`엔 decrease-key가 없어, 같은 노드가 더 작은 비용으로 재등록될 수 있음.
    - `d != dist[u]`로 낡은 후보 컷이 필수.
- INF를 `MAX - 200000` 등으로 두는 이유
    - `nd = d + w` 덧셈 시 오버플로우 방지(충분히 크되 덧셈 안전).
- 정답 구조의 직관
    - “합승 지점 k를 어디로 잡느냐”가 전부. `s→k` 함께, `k→a`, `k→b` 각자.

---

## 기억할 포인트
- 정답 공식: `min_k( distS[k] + distA[k] + distB[k])`
- 다익스트라 구현 패턴(필수)
    - PQ에 `(node, cost)` 넣고 비용 오름차순 Comparator
    - `if (d != dist[u]) continue;` stale 컷
    - 이웃 완화: `nd = d + w`, `if (nd < dist[v]) { dist[v]=nd; pq.offer(v, nd); }`
- 인덱스 통일: 1-based 입력 ↔ 0-based 내부를 확실히 구분(혼용 금지)
- 무방향 간선: 양방향 추가 잊지 말기
- 형 안전성: 합 연산이 커질 땐 `long` 고려, 최종 리턴만 `int`

