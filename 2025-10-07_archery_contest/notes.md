# 양궁대회

**작성일**: 2025.10.10</br>
**목표**: DFS(깊이 우선 탐색) + 백트래킹을 이용해
“라이언이 어피치를 가장 큰 점수 차로 이기는 화살 배치”를 찾기

---

## 최초 제출(MySubmit.java) 시 틀린 부분
1. **라이언 화살 대입 로직 오류**
   - `lion[round] = remainArrow - needArrow;` 로 작성하여 실제 사용한 화살이 아니라 남은 화살을 대입함
   - 점수 계산이 꼬이고 DFS 트리 상태가 잘못됨

2. **tie-break 비교 방향 및 조건 오류**
   - `if(best[10 - 1] < lion[10 - i])` → 인덱스 계산이 틀려 항상 `best[9]`만 비교
   - false 조건이 없어 항상 true로 갱신됨

3. **라이언 패배 케이스도 결과로 채택**
    - `if (maxDiff < diff)`만으로는 diff ≤ 0일 때도 통과
    - 무승부·패배인 경우에도 best가 갱신됨 

4. **남은 화살 처리 시점 모호**
    - `if(round == 11 || remainArrow == 0)` 한 블록에서 함께 처리
    - 0점 과녁을 지난 뒤 남은 화살을 더하는 구조로 논리적 어색함


---

## 2차 제출(MySolution.java) 시 수정한 부분
- 화살 대입 로직 정정: `lion[round] = needArrow;`
- `diff > 0` 조건 추가로 패배 케이스 제외
- `isThisBetter()` 인덱스 방향 고정(`10 - i`) 및 반대 조건(`>`) 추가
- 종료 조건 분리 및 남은 화살 처리 시점 명확화

---

## 헷갈렸던 것/ 새로 배운 것
- 백트래킹: “상태를 바꿨으면 반드시 원복해야 한다.” (`lion[idx] = value → dfs() → lion[idx] = 0`)
- 남은 화살을 0점 칸에 넣는 이유: 점수엔 영향 없고, `총합 = n` 유지 및 tie-break 상 가장 유리
- tie-break 규칙: 점수차가 같을 경우 낮은 점수(인덱스 10부터)부터 비교 → 더 많이 맞힌 배열 선택
- `diff > 0` 조건: 라이언이 이긴 경우만 결과에 반영
- 배열 복사: `clone()`을 써야 백트래킹 중에도 best 배열이 오염되지 않음

---

## 기억할 포인트
- DFS 종료 시 남은 화살은 0점 칸에 넣고 점수 계산 후 반드시 빼기
- 라이언이 이긴 경우(`diff > 0`)만 결과로 저장
- tie-break는 인덱스 10 → 0 역순 비교
- 상태 변경 후엔 반드시 백트래킹 (`lion[i] = 0`)
- “0점에 넣는다”는 명시된 규칙이 아닌, 논리적 정규화이자 관례적 처리
