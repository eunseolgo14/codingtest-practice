# 정수 삼각형

**작성일**: 2025-10-24</br>
**목표**: 완전탐색(DFS) 기반 접근에서 DP(메모이제이션)로 전환하며 효율성 통과하기.

---

## 최초 제출(MySubmit.java) 시 틀린 부분
1. **탐색 방식 – 완전탐색(DFS) 사용**
   - 모든 가능한 경로를 전부 탐색하여 최대합을 구했음.
   - 깊이 N에 대해 `O(2^N)`의 연산이 발생 → 효율성 전부 실패.
   - 동일한 하위 경로를 여러 번 재계산함.

2. **중복 계산 방지 없음**
   - 이미 계산한 `(level, index)`의 최대합 결과를 저장하지 않음.
   - 같은 노드를 중복 탐색함 → 불필요한 호출이 폭발적으로 증가.

3. **기저 조건(Base case)은 있었지만 ‘반환값 누적’ 구조 부재**
    - `sumBelow`가 `void` 반환형이라, 하위 호출 결과를 상위 호출에서 계산적으로 재활용하지 못함.
    - 따라서 `currentMax`를 “전역 비교”로만 관리 → 구조상 비효율적.

4. **DP 개념 미적용**
    - “이전 단계의 최적 결과를 기반으로 현재 값을 계산”하는 점화식 개념이 부재함.
    - 매번 하위 전체를 새로 탐색하는 구조.

---

## 2차 제출(MySolution.java) 시 수정한 부분
- 탐색 로직을 재귀 유지 + DP(메모이제이션) 추가
    - 동일한 `(level, index)`의 결과를 `currentMax[level][index]`에 저장.
    - 이미 계산된 값이면 즉시 반환 → 중복 계산 제거.
- 기저 조건(Base case) 명확화
    - 마지막 줄(`level == max_depth`)에서는 그대로 삼각형의 값 반환.
    - 더 이상 하위 호출을 하지 않음.
- 점화식 형태로 누적
    - `triangle[level][index] + Math.max(left, right)` 구조로 상위 노드의 결과를 하위 노드의 최대합과 결합.
    - “이전 결과를 재활용해 현재 최적값을 만든다”는 DP의 핵심을 코드화함.
- 전역 최대값 변수 제거
    - 전역 `currentMax` 대신 각 지점의 부분 최적값을 저장·반환.
    - 함수형(값 반환형) 구조로 변환 → 깔끔하고 재활용 가능.

---

## 헷갈렸던 것/ 새로 배운 것
- DP의 본질은 ‘기억하며 푸는 재귀’다.
    - 단순히 재귀를 돌리는 게 아니라, 하위 문제의 해를 저장하고 재사용하는 게 핵심.
- 탐색과 DP의 차이
    - BFS/DFS는 “모든 경로를 실제로 탐색”
    - DP는 “이전에 계산된 최적값을 이용해 한 번에 점프” → 결국 탐색을 계산으로 대체하는 사고 전환이 필요함.
- 기저조건의 중요성
    - DP는 “더 이상 쪼갤 수 없는 최소 단위”를 명확히 정의해줘야 작동함 (여기선 마지막 줄 값).
- 전역 비교보다 지역 반환이 더 효율적
    - “결과를 리턴 값으로 올리는 구조”는 동시성·테스트·메모리 면에서 훨씬 안정적.

---

## 기억할 포인트
- `memo[level][index]`는 “그 지점부터 내려가는 최대합”을 의미한다.
    - 상위 노드는 항상 하위 두 노드의 최적값을 기반으로 계산된다.
- DP 기본 형태:
    ```
    dp[i][j] = triangle[i][j] + Math.max(dp[i+1][j], dp[i+1][j+1]);
    //→ 위로 올라가며 최적값을 누적.
    ```
- 완전탐색의 한계는 항상 중복 계산에서 온다.
    - “한 번 계산한 것은 다시 하지 않는다”는 철칙을 기억하자.
- 재귀형 DP 구조는 유지하면서, 반환형을 int로 설계해라.
    - 전역 상태(currentMax)보다 함수형이 디버깅에 강하다.

